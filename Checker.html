<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Brand Compliance Checker</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.4.2/mammoth.browser.min.js"></script>
    <script src="https://unpkg.com/docx@7.8.2/build/index.js"></script>
    <style>
        /* Previous CSS styles remain the same */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            flex: 1;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            background: white;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 2.5em;
        }
        
        .header p {
            color: #7f8c8d;
            font-size: 1.1em;
        }
        
        .upload-section {
            background: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .upload-area {
            border: 3px dashed #bdc3c7;
            border-radius: 12px;
            padding: 50px;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s ease;
            background: #f8f9fa;
        }
        
        .upload-area:hover {
            border-color: #3498db;
            background-color: #e3f2fd;
            transform: translateY(-2px);
        }
        
        .upload-area.dragover {
            border-color: #2980b9;
            background-color: #bbdefb;
            transform: scale(1.02);
        }
        
        .upload-icon {
            font-size: 3em;
            color: #3498db;
            margin-bottom: 20px;
        }
        
        .file-input {
            display: none;
        }
        
        .brand-selection {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .brand-selection h3 {
            margin-bottom: 15px;
            color: #2c3e50;
        }
        
        .brand-checkboxes {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        
        .brand-checkbox {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 15px;
            background: white;
            border-radius: 6px;
            border: 2px solid #ecf0f1;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .brand-checkbox:hover {
            border-color: #3498db;
            background: #e8f4fd;
        }
        
        .brand-checkbox input[type="checkbox"] {
            margin: 0;
            transform: scale(1.2);
        }
        
        .text-input {
            margin-top: 30px;
        }
        
        .text-input label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .text-input textarea {
            width: 100%;
            min-height: 250px;
            padding: 20px;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            resize: vertical;
            transition: border-color 0.3s ease;
        }
        
        .text-input textarea:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        
        .analyze-btn {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            margin-top: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }
        
        .analyze-btn:hover {
            background: linear-gradient(135deg, #2980b9, #1f5f99);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        .analyze-btn:disabled {
            background: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        .results-section {
            display: none;
            background: white;
            padding: 30px;
            border-radius: 12px;
            margin-top: 20px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        
        .comparison-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-top: 30px;
        }
        
        .content-panel {
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            padding: 20px;
            background: #fafafa;
            max-height: 600px;
            overflow-y: auto;
            white-space: pre-wrap;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.5;
        }
        
        .content-panel h3 {
            margin-bottom: 20px;
            color: #2c3e50;
            font-family: 'Segoe UI', sans-serif;
            white-space: normal;
            padding-bottom: 10px;
            border-bottom: 2px solid #ecf0f1;
        }
        
        .highlight-error {
            background-color: #ffebee;
            color: #c62828;
            padding: 2px 6px;
            border-radius: 4px;
            cursor: help;
            border: 1px solid #ffcdd2;
        }
        
        .highlight-warning {
            background-color: #fff3e0;
            color: #ef6c00;
            padding: 2px 6px;
            border-radius: 4px;
            cursor: help;
            border: 1px solid #ffcc02;
        }
        
        .highlight-correction {
            background-color: #e8f5e8;
            color: #2e7d32;
            padding: 2px 6px;
            border-radius: 4px;
            border: 1px solid #c8e6c9;
        }
        
        .issues-summary {
            margin-bottom: 30px;
            padding: 20px;
            background: linear-gradient(135deg, #f8f9fa, #e9ecef);
            border-radius: 8px;
            border-left: 4px solid #3498db;
        }
        
        .issue-count {
            display: inline-block;
            margin-right: 15px;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 13px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .errors {
            background: #ffebee;
            color: #c62828;
            border: 1px solid #ffcdd2;
        }
        
        .warnings {
            background: #fff3e0;
            color: #ef6c00;
            border: 1px solid #ffcc02;
        }
        
        .corrections {
            background: #e8f5e8;
            color: #2e7d32;
            border: 1px solid #c8e6c9;
        }
        
        .download-section {
            margin-top: 30px;
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .download-btn {
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.3);
        }
        
        .download-btn:hover {
            background: linear-gradient(135deg, #229954, #1e8449);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.4);
        }
        
        .progress-bar {
            width: 100%;
            height: 6px;
            background: #ecf0f1;
            border-radius: 3px;
            overflow: hidden;
            margin: 15px 0;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3498db, #2980b9);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        .footer {
            background: #2c3e50;
            color: white;
            text-align: center;
            padding: 20px 0;
            margin-top: auto;
            font-size: 14px;
        }
        
        .footer p {
            margin: 5px 0;
        }
        
        .validation-error {
            color: #e74c3c;
            font-size: 14px;
            margin-top: 15px;
            display: none;
            padding: 10px;
            background: #fdf2f2;
            border-radius: 6px;
            border-left: 4px solid #e74c3c;
        }
        
        .disclosure-section {
            margin-top: 20px;
            padding: 15px;
            background: #fff3cd;
            border-radius: 6px;
            border-left: 4px solid #ffc107;
        }
        
        .disclosure-section h4 {
            color: #856404;
            margin-bottom: 10px;
        }
        
        .disclosure-text {
            font-size: 12px;
            color: #856404;
            font-style: italic;
        }
        
        @media (max-width: 768px) {
            .comparison-container {
                grid-template-columns: 1fr;
            }
            
            .brand-checkboxes {
                flex-direction: column;
            }
            
            .container {
                padding: 10px;
            }
        }

/* Glossary Styles */
.glossary-toggle {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: linear-gradient(135deg, #9b59b6, #8e44ad);
    color: white;
    border: none;
    padding: 15px 20px;
    border-radius: 50px;
    cursor: pointer;
    font-size: 14px;
    font-weight: 600;
    box-shadow: 0 4px 15px rgba(155, 89, 182, 0.3);
    transition: all 0.3s ease;
    z-index: 1000;
}

.glossary-toggle:hover {
    background: linear-gradient(135deg, #8e44ad, #7d3c98);
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(155, 89, 182, 0.4);
}

.glossary-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    z-index: 1001;
    display: none;
    backdrop-filter: blur(5px);
}

.glossary-modal {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    width: 90%;
    max-width: 1000px;
    height: 80%;
    background: white;
    border-radius: 12px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
    z-index: 1002;
    display: none;
    overflow: hidden;
}

.glossary-header {
    background: linear-gradient(135deg, #3498db, #2980b9);
    color: white;
    padding: 20px 30px;
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.glossary-close {
    background: none;
    border: none;
    color: white;
    font-size: 24px;
    cursor: pointer;
    padding: 5px;
    border-radius: 50%;
    transition: background 0.3s ease;
}

.glossary-close:hover {
    background: rgba(255, 255, 255, 0.2);
}

.glossary-content {
    height: calc(100% - 80px);
    overflow-y: auto;
    padding: 30px;
}

.glossary-brand {
    margin-bottom: 40px;
    border: 1px solid #ecf0f1;
    border-radius: 8px;
    overflow: hidden;
}

.glossary-brand-header {
    background: linear-gradient(135deg, #f8f9fa, #e9ecef);
    padding: 15px 20px;
    border-bottom: 1px solid #ecf0f1;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: background 0.3s ease;
}

.glossary-brand-header:hover {
    background: linear-gradient(135deg, #e9ecef, #dee2e6);
}

.glossary-brand-header h3 {
    margin: 0;
    color: #2c3e50;
    text-transform: capitalize;
}

.glossary-brand-toggle {
    font-size: 18px;
    color: #7f8c8d;
    transition: transform 0.3s ease;
}

.glossary-brand-content {
    padding: 20px;
    display: none;
}

.glossary-brand-content.active {
    display: block;
}

.glossary-brand-header.active .glossary-brand-toggle {
    transform: rotate(180deg);
}

.glossary-category {
    margin-bottom: 25px;
}

.glossary-category h4 {
    color: #3498db;
    margin-bottom: 10px;
    font-size: 16px;
    text-transform: capitalize;
    border-bottom: 2px solid #ecf0f1;
    padding-bottom: 5px;
}

.glossary-items {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
    gap: 10px;
}

.glossary-item {
    background: #f8f9fa;
    padding: 8px 12px;
    border-radius: 6px;
    font-family: 'Consolas', 'Monaco', monospace;
    font-size: 13px;
    border-left: 3px solid #3498db;
}

.glossary-item .correct {
    color: #27ae60;
    font-weight: 600;
}

.glossary-item .name {
    color: #7f8c8d;
}

.glossary-search {
    width: 100%;
    padding: 12px 15px;
    border: 2px solid #ecf0f1;
    border-radius: 8px;
    font-size: 14px;
    margin-bottom: 20px;
    transition: border-color 0.3s ease;
}

.glossary-search:focus {
    outline: none;
    border-color: #3498db;
    box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
}

@media (max-width: 768px) {
    .glossary-modal {
        width: 95%;
        height: 90%;
    }
    
    .glossary-content {
        padding: 20px;
    }
    
    .glossary-items {
        grid-template-columns: 1fr;
    }
}

    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🔍 Brand Compliance Checker</h1>
            <p>Validate your content against Signia, Rexton, and Widex nomenclature guidelines</p>
        </div>
        
        <div class="upload-section">
            <div class="upload-area" id="uploadArea">
                <div class="upload-icon">📁</div>
                <p><strong>Drop files here or click to upload</strong></p>
                <p>Supports PDF, DOCX, DOC, TXT, and HTML files</p>
                <input type="file" id="fileInput" class="file-input" accept=".pdf,.docx,.doc,.txt,.html" multiple>
            </div>
            
            <div class="brand-selection">
                <h3>Select brands to validate against (at least one required):</h3>
                <div class="brand-checkboxes">
                    <label class="brand-checkbox">
                        <input type="checkbox" id="signiaCheck">
                        <span>Signia</span>
                    </label>
                    <label class="brand-checkbox">
                        <input type="checkbox" id="rextonCheck">
                        <span>Rexton</span>
                    </label>
                    <label class="brand-checkbox">
                        <input type="checkbox" id="widexCheck">
                        <span>Widex</span>
                    </label>
                </div>
            </div>
            <div class="validation-error" id="brandValidationError">
                Please select at least one brand to validate against.
            </div>
            
            <div class="text-input">
                <label for="textArea">Or paste your text here:</label>
                <textarea id="textArea" placeholder="Paste your marketing content here for analysis..."></textarea>
            </div>
            
            <button class="analyze-btn" id="analyzeBtn" disabled>🔍 Analyze Content</button>
            <div class="progress-bar" id="progressBar" style="display: none;">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
        
        <div class="results-section" id="resultsSection">
            <div class="issues-summary" id="issuesSummary"></div>
            
            <div class="comparison-container">
                <div class="content-panel">
                    <h3>📄 Original Content</h3>
                    <div id="originalContent"></div>
                </div>
                <div class="content-panel">
                    <h3>✅ Corrected Content</h3>
                    <div id="correctedContent"></div>
                </div>
            </div>
            
            <div class="disclosure-section" id="disclosureSection" style="display: none;">
                <h4>📋 Required Disclosures</h4>
                <div id="disclosureText" class="disclosure-text"></div>
            </div>
            
            <div class="download-section">
                <button class="download-btn" id="downloadBtn">📥 Download Corrected Document (.docx)</button>
            </div>
        </div>
    </div>
    
    <footer class="footer">
        <p>Brand Compliance Checker v2.5.3</p>
        <p>Last Updated: <span id="lastModified"></span></p>
        <p>&copy; 2025 WS Audiology. All rights reserved.</p>
    </footer>

    <script>
        // Load brand rules from the actual nomenclature documents
        const brandRules = {
            signia: {
                platforms: [
                    { name: 'Signia Integrated Xperience', correct: 'Signia Integrated Xperience™' },
                    { name: 'Signia Augmented Xperience', correct: 'Signia Augmented Xperience' },
                    { name: 'Signia Xperience', correct: 'Signia Xperience' },
                    { name: 'Signia Nx', correct: 'Signia Nx' }
                ],
                products: [
                    { name: 'Active', correct: 'Active' },
                    { name: 'Active Pro', correct: 'Active Pro' },
                    { name: 'Insio Charge&Go AX', correct: 'Insio™ Charge&Go AX' },
                    { name: 'Insio IX', correct: 'Insio™ IX' },
                    { name: 'Insio IX IIC/CIC', correct: 'Insio IX IIC/CIC' },
                    { name: 'Insio Nx', correct: 'Insio™ Nx' },
                    { name: 'Intuis 3 CIC', correct: 'Intuis™ 3 CIC' },
                    { name: 'Intuis 3 ITC', correct: 'Intuis™ 3 ITC' },
                    { name: 'Intuis 3 ITE', correct: 'Intuis™ 3 ITE' },
                    { name: 'Intuis 3 Click CIC', correct: 'Intuis™ 3 Click CIC' },
                    { name: 'Intuis 3 Click ITC', correct: 'Intuis™ 3 Click ITC' },
                    { name: 'Intuis 3 RIC312', correct: 'Intuis™ 3 RIC312' },
                    { name: 'Intius 3 M', correct: 'Intius™ 3 M' },
                    { name: 'Intius 3 P', correct: 'Intius™ 3 P' },
                    { name: 'Intius 3 S', correct: 'Intius™ 3 S' },
                    { name: 'Intius 3 SP', correct: 'Intius™ 3 SP' },
                    { name: 'Motion 13 Nx', correct: 'Motion™ 13 Nx' },
                    { name: 'Motion 13P Nx', correct: 'Motion™ 13P Nx' },
                    { name: 'Motion Charge&Go P X', correct: 'Motion™ Charge&Go P X' },
                    { name: 'Motion Charge&Go SP X', correct: 'Motion™ Charge&Go SP X' },
                    { name: 'Motion Charge&Go X', correct: 'Motion™ Charge&Go X' },
                    { name: 'Pure 312 AX', correct: 'Pure™ 312 AX' },
                    { name: 'Pure 312 X', correct: 'Pure™ 312 X' },
                    { name: 'Pure Charge&Go AX', correct: 'Pure™ Charge&Go AX' },
                    { name: 'Pure Charge&Go IX', correct: 'Pure™ Charge&Go IX' },
                    { name: 'Pure Charge&Go T AX', correct: 'Pure™ Charge&Go T AX' },
                    { name: 'Pure Charge&Go T IX', correct: 'Pure™ Charge&Go T IX' },
                    { name: 'Pure Charge&Go X', correct: 'Pure™ Charge&Go X' },
                    { name: 'Silk Charge&Go IX', correct: 'Silk™ Charge&Go IX' },
                    { name: 'Styletto AX', correct: 'Styletto™ AX' },
                    { name: 'Styletto IX', correct: 'Styletto™ IX' },
                    { name: 'Styletto X', correct: 'Styletto™ X' },
                    { name: 'Silk X', correct: 'Silk™ X' }
                ],
                features: [
                    { name: 'Augmented Focus', correct: 'Augmented Focus™' },
                    { name: 'AutoFit', correct: 'AutoFit™' },
                    { name: 'Connexx', correct: 'Connexx™' },
                    { name: 'e2e Wireless', correct: 'e2e Wireless™' },
                    { name: 'eWindScreen', correct: 'eWindScreen™' },
                    { name: 'OVP', correct: 'OVP™' },
                    { name: 'SoundSmoothing', correct: 'SoundSmoothing™' },
                    { name: 'TruAcoustics', correct: 'TruAcoustics™' }
                ],
                phoneFormat: '(800) 766-4500',
                disclosure: 'Signia is a registered trademark of WSAUD A/S.'
            },
            rexton: {
                platforms: [
                    { name: 'BiCore', correct: 'BiCore™' },
                    { name: 'MotionCore', correct: 'MotionCore™' },
                    { name: 'MyCore', correct: 'MyCore™' },
                    { name: 'Reach', correct: 'Reach' },
                    { name: 'TruCore', correct: 'TruCore' }
                ],
                products: [
                    { name: 'BiCore B-Li M Rugged', correct: 'BiCore™ B-Li M Rugged' },
                    { name: 'BiCore B M', correct: 'BiCore™ B M' },
                    { name: 'BiCore B P', correct: 'BiCore™ B P' },
                    { name: 'BiCore B HP', correct: 'BiCore™ B HP' },
                    { name: 'BiCore C R-Li', correct: 'BiCore™ C R-Li' },
                    { name: 'BiCore C R-Li T', correct: 'BiCore™ C R-Li T' },
                    { name: 'BiCore Custom Li', correct: 'BiCore™ Custom Li' },
                    { name: 'BiCore R-Li', correct: 'BiCore™ R-Li' },
                    { name: 'BiCore R-Li T', correct: 'BiCore™ R-Li T' },
                    { name: 'BiCore R312', correct: 'BiCore™ R312' },
                    { name: 'BiCore SR', correct: 'BiCore™ SR' },
                    { name: 'M-Core B-Li M', correct: 'M-Core™ B-Li M' },
                    { name: 'M-Core B-Li P', correct: 'M-Core™ B-Li P' },
                    { name: 'M-Core B-Li HP', correct: 'M-Core™ B-Li HP' },
                    { name: 'M-Core iX-CIC', correct: 'M-Core™ iX-CIC' },
                    { name: 'M-Core R-Li', correct: 'M-Core™ R-Li' },
                    { name: 'M-Core R-Li T', correct: 'M-Core™ R-Li T' },
                    { name: 'M-Core R312', correct: 'M-Core™ R312' },
                    { name: 'M-Core SR', correct: 'M-Core™ SR' },
                    { name: 'Mosaic HP 6C BTE', correct: 'Mosaic HP 6C BTE' },
                    { name: 'Mosaic M 8C BTE', correct: 'Mosaic M 8C BTE' },
                    { name: 'Mosaic P 8C BTE', correct: 'Mosaic P 8C BTE' },
                    { name: 'Reach inoX-CIC Li', correct: 'Reach inoX-CIC Li' },
                    { name: 'Reach R-Li T', correct: 'Reach R-Li T' },
                    { name: 'Sterling 8C Customs', correct: 'Sterling 8C Customs' }
                ],
                features: [
                    { name: 'AutoFit', correct: 'AutoFit™' },
                    { name: 'Connexx', correct: 'Connexx™' },
                    { name: 'Lifeproof', correct: 'Lifeproof™' },
                    { name: 'SoundSmoothing', correct: 'SoundSmoothing™' }
                ],
                phoneFormat: '(800) 876-1141',
                disclosure: 'Rexton is a registered trademark of WSAUD A/S.'
            },
            widex: {
                products: [
                    { name: 'Widex SmartRIC', correct: 'Widex SmartRIC™' },
                    { name: 'SmartRIC', correct: 'SmartRIC™' },
                    { name: 'Widex Moment Sheer', correct: 'Widex Moment Sheer™' },
                    { name: 'Moment Sheer', correct: 'Moment Sheer™' },
                    { name: 'Widex Moment', correct: 'Widex Moment™' },
                    { name: 'Moment', correct: 'Moment™' },
                    { name: 'Widex Magnify', correct: 'Widex Magnify' },
                    { name: 'Magnify', correct: 'Magnify' },
                    { name: 'Widex Evoke', correct: 'Widex Evoke™' },
                    { name: 'Evoke', correct: 'Evoke™' },
                    { name: 'Widex Allure', correct: 'Widex Allure™' },
                    { name: 'Evoke', correct: 'Evoke™' }
                ],
                features: [
                    { name: 'CAMISHA', correct: 'CAMISHA™' },
                    { name: 'Compass GPS', correct: 'Compass™ GPS' },
                    { name: 'Echo-Free', correct: 'Echo-Free™' },
                    { name: 'NanoCare', correct: 'NanoCare™' },
                    { name: 'PureSound', correct: 'PureSound™' },
                    { name: 'SoundRelax', correct: 'SoundRelax™' },
                    { name: 'TruAcoustics', correct: 'TruAcoustics™' },
                    { name: 'WidexLink', correct: 'WidexLink™' },
                    { name: 'ZeroDelay', correct: 'ZeroDelay™' }
                ],
                accessories: [
                    { name: 'COM-DEX', correct: 'COM-DEX™' },
                    { name: 'COM-DEX Remote Mic', correct: 'COM-DEX™ Remote Mic' },
                    { name: 'PHONE-DEX 2', correct: 'PHONE-DEX™ 2' },
                    { name: 'RC-DEX', correct: 'RC-DEX™' },
                    { name: 'TV-DEX', correct: 'TV-DEX™' },
                    { name: 'TV PLAY', correct: 'TV PLAY™' },
                    { name: 'Widex Sound Assist', correct: 'Widex Sound Assist™' }
                ],
                phoneFormat: '1.800.221.0188',
                disclosure: 'Widex is a registered trademark of WSAUD A/S.'
            }
        };

        const commonTerms = {
            replacements: {
                'patients': 'wearers',
                'customers': 'wearers',
                'clients': 'wearers',
                'patient': 'wearer',
                'customer': 'wearer',
                'client': 'wearer'
            },
            capitalizations: {
                'hcp': 'HCP',
                'hcps': 'HCPs',
                'hearing care professional': 'Hearing Care Professional',
                'hearing care professionals': 'Hearing Care Professionals'
            },
            styles: ['BTE', 'RIC', 'ITE', 'ITC', 'CIC', 'IIC', 'RITE'],
            disclosures: {
                bluetooth: 'Bluetooth® word mark and logos are owned by the Bluetooth SIG, Inc. and any use of such marks by WSAUD A/S is under license.',
                apple: 'Apple, the Apple logo and iPhone are trademarks of Apple Inc., registered in the U.S. and other countries. App Store is a service mark of Apple Inc.',
                android: 'Android, Google Play and the Google Play logo are trademarks of Google Inc.'
            }
        };

        class BrandComplianceChecker {
            constructor() {
                this.originalText = '';
                this.correctedText = '';
                this.issues = [];
                this.firstMentions = new Set();
                this.requiredDisclosures = new Set();
                this.initializeEventListeners();
                this.setLastModified();
            }
            
            setLastModified() {
                const lastModifiedElement = document.getElementById('lastModified');
                const now = new Date();
                const options = { 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric',
                    hour: '2-digit',
                    minute: '2-digit'
                };
                lastModifiedElement.textContent = now.toLocaleDateString('en-US', options);
            }
            
            initializeEventListeners() {
                const uploadArea = document.getElementById('uploadArea');
                const fileInput = document.getElementById('fileInput');
                const textArea = document.getElementById('textArea');
                const analyzeBtn = document.getElementById('analyzeBtn');
                const downloadBtn = document.getElementById('downloadBtn');
                
                uploadArea.addEventListener('click', () => fileInput.click());
                uploadArea.addEventListener('dragover', this.handleDragOver.bind(this));
                uploadArea.addEventListener('drop', this.handleDrop.bind(this));
                uploadArea.addEventListener('dragleave', this.handleDragLeave.bind(this));
                
                fileInput.addEventListener('change', this.handleFileSelect.bind(this));
                analyzeBtn.addEventListener('click', this.analyzeContent.bind(this));
                downloadBtn.addEventListener('click', this.downloadCorrectedContent.bind(this));
                
                const checkboxes = document.querySelectorAll('input[type="checkbox"]');
                checkboxes.forEach(checkbox => {
                    checkbox.addEventListener('change', this.updateFormValidation.bind(this));
                });
                
                textArea.addEventListener('input', this.updateFormValidation.bind(this));
            }
            
            updateFormValidation() {
                const textArea = document.getElementById('textArea');
                const analyzeBtn = document.getElementById('analyzeBtn');
                const errorElement = document.getElementById('brandValidationError');
                
                const checkboxes = document.querySelectorAll('input[type="checkbox"]');
                const isAnyChecked = Array.from(checkboxes).some(cb => cb.checked);
                const hasText = textArea.value.trim().length > 0;
                
                if (isAnyChecked) {
                    errorElement.style.display = 'none';
                } else {
                    errorElement.style.display = 'block';
                }
                
                analyzeBtn.disabled = !(hasText && isAnyChecked);
            }
            
            handleDragOver(e) {
                e.preventDefault();
                e.currentTarget.classList.add('dragover');
            }
            
            handleDragLeave(e) {
                e.currentTarget.classList.remove('dragover');
            }
            
            handleDrop(e) {
                e.preventDefault();
                e.currentTarget.classList.remove('dragover');
                const files = Array.from(e.dataTransfer.files);
                this.processFiles(files);
            }
            
            handleFileSelect(e) {
                const files = Array.from(e.target.files);
                this.processFiles(files);
            }
            
            async processFiles(files) {
                const analyzeBtn = document.getElementById('analyzeBtn');
                const progressBar = document.getElementById('progressBar');
                const progressFill = document.getElementById('progressFill');
                
                progressBar.style.display = 'block';
                analyzeBtn.disabled = true;
                
                let combinedText = '';
                
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    progressFill.style.width = `${(i / files.length) * 100}%`;
                    
                    try {
                        const text = await this.extractTextFromFile(file);
                        combinedText += text + '\n\n';
                    } catch (error) {
                        console.error(`Error processing file ${file.name}:`, error);
                        alert(`Error processing file ${file.name}. Please try again.`);
                    }
                }
                
                if (combinedText.trim()) {
                    document.getElementById('textArea').value = combinedText.trim();
                    this.updateFormValidation();
                }
                
                progressFill.style.width = '100%';
                setTimeout(() => {
                    progressBar.style.display = 'none';
                    progressFill.style.width = '0%';
                }, 1000);
            }
            
            async extractTextFromFile(file) {
                const fileType = file.type;
                const fileName = file.name.toLowerCase();
                
                if (fileType === 'text/plain' || fileName.endsWith('.txt')) {
                    return await this.readTextFile(file);
                } else if (fileType === 'text/html' || fileName.endsWith('.html')) {
                    return await this.readHTMLFile(file);
                } else if (fileType === 'application/pdf' || fileName.endsWith('.pdf')) {
                    return await this.readPDFFile(file);
                } else if (fileType === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' || fileName.endsWith('.docx')) {
                    return await this.readDOCXFile(file);
                } else if (fileType === 'application/msword' || fileName.endsWith('.doc')) {
                    throw new Error('DOC files are not supported. Please convert to DOCX format.');
                } else {
                    throw new Error('Unsupported file type');
                }
            }
            
            readTextFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => resolve(e.target.result);
                    reader.onerror = () => reject(new Error('Failed to read text file'));
                    reader.readAsText(file);
                });
            }
            
            readHTMLFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const parser = new DOMParser();
                            const doc = parser.parseFromString(e.target.result, 'text/html');
                            resolve(doc.body.textContent || doc.body.innerText || '');
                        } catch (error) {
                            reject(new Error('Failed to parse HTML file'));
                        }
                    };
                    reader.onerror = () => reject(new Error('Failed to read HTML file'));
                    reader.readAsText(file);
                });
            }
            
            async readPDFFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const arrayBuffer = e.target.result;
                            const pdf = await pdfjsLib.getDocument(arrayBuffer).promise;
                            let fullText = '';
                            
                            for (let i = 1; i <= pdf.numPages; i++) {
                                const page = await pdf.getPage(i);
                                const textContent = await page.getTextContent();
                                const pageText = textContent.items.map(item => item.str).join(' ');
                                fullText += pageText + '\n';
                            }
                            
                            resolve(fullText);
                        } catch (error) {
                            reject(new Error('Failed to read PDF file'));
                        }
                    };
                    reader.onerror = () => reject(new Error('Failed to read PDF file'));
                    reader.readAsArrayBuffer(file);
                });
            }
            
            async readDOCXFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = async (e) => {
                        try {
                            const arrayBuffer = e.target.result;
                            const result = await mammoth.extractRawText({ arrayBuffer: arrayBuffer });
                            resolve(result.value);
                        } catch (error) {
                            reject(new Error('Failed to read DOCX file'));
                        }
                    };
                    reader.onerror = () => reject(new Error('Failed to read DOCX file'));
                    reader.readAsArrayBuffer(file);
                });
            }
            
isHeader(line, lineIndex, lines) {
    const trimmedLine = line.trim();
    if (!trimmedLine) return false;
    
    // PRIMARY CHECK: Word count (headers typically have fewer words)
    const words = trimmedLine.split(/\s+/).filter(word => word.length > 0);
    const wordCount = words.length;
    
    // Headers are typically 12 words or fewer
    if (wordCount > 12) return false;
    
    // Additional header indicators
    const hasEmojis = /[\u{1F300}-\u{1F9FF}]/u.test(trimmedLine);
    const hasExclamation = trimmedLine.includes('!');
    const isAllCaps = trimmedLine === trimmedLine.toUpperCase();
    const startsWithHeading = /^heading:/i.test(trimmedLine);
    
    // Check if surrounded by blank lines
    const prevLine = lineIndex > 0 ? lines[lineIndex - 1].trim() : '';
    const nextLine = lineIndex < lines.length - 1 ? lines[lineIndex + 1].trim() : '';
    const surroundedByBlankLines = (!prevLine || !nextLine);
    
    // Enhanced header detection based on word count and characteristics
    const isLikelyHeader = 
        (wordCount <= 8) || // Very short lines are likely headers
        (wordCount <= 12 && (
            surroundedByBlankLines || 
            hasEmojis || 
            hasExclamation ||
            isAllCaps ||
            startsWithHeading ||
            this.isTitleCase(trimmedLine)
        ));
    
    return isLikelyHeader;
}

// Helper function for better title case detection
isTitleCase(text) {
    // Remove emojis and special characters for title case check
    const cleanText = text.replace(/[\u{1F300}-\u{1F9FF}!:]/gu, '').trim();
    if (!cleanText) return false;
    
    const words = cleanText.split(/\s+/).filter(word => word.length > 0);
    if (words.length === 0) return false;
    
    return words.every(word => {
        if (word.length === 0) return true;
        return word.charAt(0) === word.charAt(0).toUpperCase();
    });
}


            
analyzeContent() {
    const textArea = document.getElementById('textArea');
    const text = textArea.value.trim();
    
    if (!text) {
        alert('Please upload a file or enter text to analyze.');
        return;
    }
    
    const checkboxes = document.querySelectorAll('input[type="checkbox"]');
    const isAnyChecked = Array.from(checkboxes).some(cb => cb.checked);
    if (!isAnyChecked) {
        alert('Please select at least one brand to validate against.');
        return;
    }
    
    this.originalText = text;
    this.correctedText = text;
    this.issues = [];
    this.firstMentions = new Set();
    this.requiredDisclosures = new Set();
    // REMOVED: this.trackedCorrections = new Set();
    
    // Apply corrections in specific order
    this.applyCommonTerminologyFixes();
    this.applyDisclosureRules();
    this.applyBrandSpecificRules();
    this.applyStyleCorrections();
    this.applyPhoneNumberFormatting();
    
    this.displayResults();
}
            
            applyCommonTerminologyFixes() {
                // Fix common terminology
                Object.entries(commonTerms.replacements).forEach(([incorrect, correct]) => {
                    const regex = new RegExp(`\\b${this.escapeRegex(incorrect)}\\b`, 'gi');
                    this.correctedText = this.correctedText.replace(regex, correct);
                });
                
                // Fix capitalization
                Object.entries(commonTerms.capitalizations).forEach(([incorrect, correct]) => {
                    const regex = new RegExp(`\\b${this.escapeRegex(incorrect)}\\b`, 'gi');
                    this.correctedText = this.correctedText.replace(regex, correct);
                });
            }
            
            applyDisclosureRules() {
                // Process Apple/iPhone FIRST (highest priority)
                this.processAppleTerms();
                
                // Process iOS (no trademark symbols)
                this.processiOSTerms();
                
                // Process Android LAST (with ™ symbol)
                this.processAndroidTerms();
                
                // Process Bluetooth
                this.processBluetoothTerms();
            }
            
            processAppleTerms() {
                // Handle iPhone variations - FIXED: Only match terms WITHOUT existing trademark symbols
                const iPhoneVariants = ['iphone', 'Iphone', 'IPhone', 'IPHONE'];
                let isFirstMention = !this.firstMentions.has('iphone');
                
                iPhoneVariants.forEach(variant => {
                    // CRITICAL FIX: Negative lookahead to avoid matching terms that already have trademark symbols
                    const regex = new RegExp(`\\b${this.escapeRegex(variant)}\\b(?![™®])`, 'g');
                    
                    if (isFirstMention && this.correctedText.match(regex)) {
                        this.correctedText = this.correctedText.replace(regex, 'iPhone®');
                        this.firstMentions.add('iphone');
                        this.requiredDisclosures.add('apple');
                        isFirstMention = false;
                    } else {
                        this.correctedText = this.correctedText.replace(regex, 'iPhone');
                    }
                });
                
                // Handle Apple variations - FIXED: Only match terms WITHOUT existing trademark symbols
                const appleVariants = ['apple', 'APPLE'];
                let isFirstAppleMention = !this.firstMentions.has('apple');
                
                appleVariants.forEach(variant => {
                    const regex = new RegExp(`\\b${this.escapeRegex(variant)}\\b(?![™®])`, 'g');
                    
                    if (isFirstAppleMention && this.correctedText.match(regex)) {
                        this.correctedText = this.correctedText.replace(regex, 'Apple®');
                        this.firstMentions.add('apple');
                        this.requiredDisclosures.add('apple');
                        isFirstAppleMention = false;
                    } else {
                        this.correctedText = this.correctedText.replace(regex, 'Apple');
                    }
                });
                
                // Handle made-for-iPhone - FIXED: Only match terms WITHOUT existing trademark symbols
                const madeForIPhoneVariants = ['made for iPhone', 'made for iphone', 'Made For iPhone'];
                madeForIPhoneVariants.forEach(variant => {
                    const regex = new RegExp(`${this.escapeRegex(variant)}(?![™®])`, 'gi');
                    if (!this.firstMentions.has('made-for-iphone') && this.correctedText.match(regex)) {
                        this.correctedText = this.correctedText.replace(regex, 'made-for-iPhone®');
                        this.firstMentions.add('made-for-iphone');
                        this.requiredDisclosures.add('apple');
                    } else {
                        this.correctedText = this.correctedText.replace(regex, 'made-for-iPhone');
                    }
                });
            }
            
            processiOSTerms() {
                // iOS gets no trademark symbols but needs correct capitalization
                const iOSVariants = ['ios', 'IOS', 'Ios'];
                iOSVariants.forEach(variant => {
                    const regex = new RegExp(`\\b${this.escapeRegex(variant)}\\b`, 'g');
                    this.correctedText = this.correctedText.replace(regex, 'iOS');
                });
            }
            
            processAndroidTerms() {
                // Handle Android variations - FIXED: Only match terms WITHOUT existing trademark symbols
                const androidVariants = ['android', 'ANDROID'];
                let isFirstMention = !this.firstMentions.has('android');
                
                androidVariants.forEach(variant => {
                    const regex = new RegExp(`\\b${this.escapeRegex(variant)}\\b(?![™®])`, 'g');
                    
                    if (isFirstMention && this.correctedText.match(regex)) {
                        this.correctedText = this.correctedText.replace(regex, 'Android™');
                        this.firstMentions.add('android');
                        this.requiredDisclosures.add('android');
                        isFirstMention = false;
                    } else {
                        this.correctedText = this.correctedText.replace(regex, 'Android');
                    }
                });
            }
            
            processBluetoothTerms() {
                // FIXED: Only match terms WITHOUT existing trademark symbols
                const bluetoothVariants = ['bluetooth', 'Bluetooth', 'BLUETOOTH'];
                let isFirstMention = !this.firstMentions.has('bluetooth');
                
                bluetoothVariants.forEach(variant => {
                    const regex = new RegExp(`\\b${this.escapeRegex(variant)}\\b(?![™®])`, 'g');
                    
                    if (isFirstMention && this.correctedText.match(regex)) {
                        this.correctedText = this.correctedText.replace(regex, 'Bluetooth®');
                        this.firstMentions.add('bluetooth');
                        this.requiredDisclosures.add('bluetooth');
                        isFirstMention = false;
                    } else {
                        this.correctedText = this.correctedText.replace(regex, 'Bluetooth');
                    }
                });
            }
            
            applyBrandSpecificRules() {
                const selectedBrands = this.getSelectedBrands();
                
                selectedBrands.forEach(brand => {
                    const rules = brandRules[brand];
                    
                    // Process platforms
                    if (rules.platforms) {
                        rules.platforms.forEach(platform => {
                            this.processProductName(platform, brand);
                        });
                    }
                    
                    // Process products
                    rules.products.forEach(product => {
                        this.processProductName(product, brand);
                    });
                    
                    // Process features
                    if (rules.features) {
                        rules.features.forEach(feature => {
                            this.processProductName(feature, brand);
                        });
                    }
                    
                    // Process accessories
                    if (rules.accessories) {
                        rules.accessories.forEach(accessory => {
                            this.processProductName(accessory, brand);
                        });
                    }
                });
            }
            
processProductName(product, brand) {
    const baseName = product.name;
    const correctName = product.correct;
    const baseNameLower = baseName.toLowerCase();
    
    // Only process if we haven't seen this term before
    if (!this.firstMentions.has(baseNameLower)) {
        const escapedBaseName = this.escapeRegex(baseName);
        const regex = new RegExp(`\\b${escapedBaseName}\\b(?![™®])`, 'i');
        
        // FIXED: Process line by line to skip headers
        const lines = this.correctedText.split('\n');
        let foundFirstBodyMention = false;
        let issuePosition = -1;
        let originalMatch = '';
        
        for (let i = 0; i < lines.length; i++) {
            const line = lines[i];
            
            // Skip if this line is a header
            if (this.isHeader(line, i, lines)) {
                continue;
            }
            
            // Look for the term in non-header lines only
            const match = line.match(regex);
            if (match && !foundFirstBodyMention) {
                // Replace only this first body text occurrence
                lines[i] = line.replace(regex, correctName);
                foundFirstBodyMention = true;
                
                // Calculate position in original text for issue tracking
                const linesBeforeMatch = this.originalText.split('\n').slice(0, i);
                const textBeforeMatch = linesBeforeMatch.join('\n') + (i > 0 ? '\n' : '');
                issuePosition = textBeforeMatch.length + line.indexOf(match[0]);
                originalMatch = match[0];
                
                break; // Stop after first body text match
            }
        }
        
        if (foundFirstBodyMention) {
            this.correctedText = lines.join('\n');
            this.firstMentions.add(baseNameLower);
            
            // Track the issue
            if (issuePosition !== -1) {
                this.addIssue(
                    issuePosition, 
                    originalMatch, 
                    correctName, 
                    'trademark', 
                    `Add trademark symbol: "${originalMatch}" → "${correctName}"`
                );
            }
        }
    }
}

         
            applyStyleCorrections() {
                commonTerms.styles.forEach(style => {
                    const regex = new RegExp(`\\b${this.escapeRegex(style.toLowerCase())}\\b`, 'gi');
                    this.correctedText = this.correctedText.replace(regex, style);
                });
                
                // Fix app to lowercase when used generically
                const appRegex = /\bApp\b(?!\s+Store)/g;
                this.correctedText = this.correctedText.replace(appRegex, 'app');
            }
            
            applyPhoneNumberFormatting() {
                const selectedBrands = this.getSelectedBrands();
                
                selectedBrands.forEach(brand => {
                    const rules = brandRules[brand];
                    if (rules.phoneFormat) {
                        // This is a simplified phone number correction
                        // In a real implementation, you'd want more sophisticated phone number detection
                        const phoneRegex = /\b\d{3}[-.\s]?\d{3}[-.\s]?\d{4}\b/g;
                        // For demo purposes, we'll just flag phone numbers that don't match the expected format
                    }
                });
            }
            
            getSelectedBrands() {
                const brands = [];
                if (document.getElementById('signiaCheck').checked) brands.push('signia');
                if (document.getElementById('rextonCheck').checked) brands.push('rexton');
                if (document.getElementById('widexCheck').checked) brands.push('widex');
                return brands;
            }
            
addIssue(position, original, corrected, type, description) {
    this.issues.push({
        position,
        original,
        corrected,
        type,
        description
    });
}

            
            displayResults() {
                const resultsSection = document.getElementById('resultsSection');
                resultsSection.style.display = 'block';
                
                this.displayIssuesSummary();
                this.displayOriginalContent();
                this.displayCorrectedContent();
                this.displayRequiredDisclosures();
                
                // Scroll to results
                resultsSection.scrollIntoView({ behavior: 'smooth' });
            }
            
            displayIssuesSummary() {
                const summaryContainer = document.getElementById('issuesSummary');
                
                const errors = this.issues.filter(issue => issue.type === 'error').length;
                const warnings = this.issues.filter(issue => issue.type === 'warning').length;
                const corrections = this.issues.filter(issue => 
                    ['terminology', 'capitalization', 'trademark'].includes(issue.type)
                ).length;
                
                summaryContainer.innerHTML = `
                    <h3>📊 Analysis Summary</h3>
                    <div style="margin-top: 15px;">
                        <span class="issue-count errors">Errors: ${errors}</span>
                        <span class="issue-count warnings">Warnings: ${warnings}</span>
                        <span class="issue-count corrections">Corrections: ${corrections}</span>
                    </div>
                    <p style="margin-top: 15px; font-size: 16px;"><strong>Total issues found: ${this.issues.length}</strong></p>
                `;
            }
            
            displayOriginalContent() {
                const container = document.getElementById('originalContent');
                if (!container) return;
                
                const fragment = document.createDocumentFragment();
                let lastIndex = 0;
                
                const sortedIssues = [...this.issues].sort((a, b) => a.position - b.position);
                
                sortedIssues.forEach(issue => {
                    if (issue.position > lastIndex) {
                        const textNode = document.createTextNode(
                            this.originalText.substring(lastIndex, issue.position)
                        );
                        fragment.appendChild(textNode);
                    }
                    
                    const span = document.createElement('span');
                    span.className = this.getHighlightClass(issue.type);
                    span.title = issue.description;
                    span.textContent = issue.original;
                    fragment.appendChild(span);
                    
                    lastIndex = issue.position + issue.original.length;
                });
                
                if (lastIndex < this.originalText.length) {
                    const textNode = document.createTextNode(
                        this.originalText.substring(lastIndex)
                    );
                    fragment.appendChild(textNode);
                }
                
                container.innerHTML = '';
                container.appendChild(fragment);
            }
            
            displayCorrectedContent() {
                const container = document.getElementById('correctedContent');
                if (!container) return;
                
                container.textContent = this.correctedText;
            }
            
            displayRequiredDisclosures() {
                const disclosureSection = document.getElementById('disclosureSection');
                const disclosureText = document.getElementById('disclosureText');
                
                if (this.requiredDisclosures.size > 0) {
                    disclosureSection.style.display = 'block';
                    
                    let disclosureHTML = '<p><strong>Copy and paste these required disclosures:</strong></p>';
                    
                    this.requiredDisclosures.forEach(disclosure => {
                        if (commonTerms.disclosures[disclosure]) {
                            disclosureHTML += `<p style="margin: 10px 0; padding: 10px; background: white; border-radius: 4px;">${commonTerms.disclosures[disclosure]}</p>`;
                        }
                    });
                    
                    // Add brand-specific disclosures
                    const selectedBrands = this.getSelectedBrands();
                    selectedBrands.forEach(brand => {
                        const rules = brandRules[brand];
                        if (rules.disclosure) {
                            disclosureHTML += `<p style="margin: 10px 0; padding: 10px; background: white; border-radius: 4px;">${rules.disclosure}</p>`;
                        }
                    });
                    
                    disclosureText.innerHTML = disclosureHTML;
                } else {
                    disclosureSection.style.display = 'none';
                }
            }
            
            getHighlightClass(type) {
                switch (type) {
                    case 'error': return 'highlight-error';
                    case 'warning': return 'highlight-warning';
                    case 'terminology':
                    case 'capitalization':
                    case 'trademark':
                        return 'highlight-error';
                    default: return 'highlight-correction';
                }
            }
            
            async downloadCorrectedContent() {
                try {
                    const doc = new docx.Document({
                        sections: [{
                            properties: {},
                            children: this.correctedText.split('\n').map(line => 
                                new docx.Paragraph({
                                    children: [new docx.TextRun(line || ' ')],
                                })
                            ),
                        }],
                    });
                    
                    const blob = await docx.Packer.toBlob(doc);
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'brand-compliant-content.docx';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (error) {
                    console.error('Error generating DOCX:', error);
                    const blob = new Blob([this.correctedText], { type: 'text/plain;charset=utf-8' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = 'brand-compliant-content.txt';
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    alert('DOCX generation failed. Downloaded as text file instead.');
                }
            }
            
            escapeRegex(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new BrandComplianceChecker();
        });

// Fixed Glossary functionality with working search
class GlossaryManager {
    constructor() {
        this.initializeGlossary();
    }
    
    initializeGlossary() {
        const toggleBtn = document.getElementById('glossaryToggle');
        const overlay = document.getElementById('glossaryOverlay');
        const modal = document.getElementById('glossaryModal');
        const closeBtn = document.getElementById('glossaryClose');
        const searchInput = document.getElementById('glossarySearch');
        
        toggleBtn.addEventListener('click', () => this.showGlossary());
        closeBtn.addEventListener('click', () => this.hideGlossary());
        overlay.addEventListener('click', () => this.hideGlossary());
        
        // FIXED: Add debounced search for better performance
        searchInput.addEventListener('input', this.debounce((e) => {
            this.filterGlossary(e.target.value);
        }, 300));
        
        // Close on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && modal.style.display === 'block') {
                this.hideGlossary();
            }
        });
    }
    
    // FIXED: Add debounce function for search performance
    debounce(func, wait) {
        let timeout;
        return function executedFunction(...args) {
            const later = () => {
                clearTimeout(timeout);
                func(...args);
            };
            clearTimeout(timeout);
            timeout = setTimeout(later, wait);
        };
    }
    
    showGlossary() {
        this.generateGlossaryContent();
        document.getElementById('glossaryOverlay').style.display = 'block';
        document.getElementById('glossaryModal').style.display = 'block';
        document.body.style.overflow = 'hidden';
        
        // Clear search on show
        document.getElementById('glossarySearch').value = '';
    }
    
    hideGlossary() {
        document.getElementById('glossaryOverlay').style.display = 'none';
        document.getElementById('glossaryModal').style.display = 'none';
        document.body.style.overflow = 'auto';
    }
    
    generateGlossaryContent() {
        const container = document.getElementById('glossaryContainer');
        container.innerHTML = '';
        
        // Generate content from brandRules JSON
        Object.entries(brandRules).forEach(([brandName, brandData]) => {
            const brandSection = this.createBrandSection(brandName, brandData);
            container.appendChild(brandSection);
        });
        
        // Add common terms section
        const commonSection = this.createCommonTermsSection();
        container.appendChild(commonSection);
    }
    
    createBrandSection(brandName, brandData) {
        const section = document.createElement('div');
        section.className = 'glossary-brand';
        section.setAttribute('data-brand', brandName);
        
        const header = document.createElement('div');
        header.className = 'glossary-brand-header';
        header.innerHTML = `
            <h3>${brandName.charAt(0).toUpperCase() + brandName.slice(1)} Nomenclature</h3>
            <span class="glossary-brand-toggle">▼</span>
        `;
        
        const content = document.createElement('div');
        content.className = 'glossary-brand-content';
        
        // Add categories dynamically from JSON
        Object.entries(brandData).forEach(([categoryName, items]) => {
            if (Array.isArray(items) && items.length > 0) {
                const category = this.createCategory(categoryName, items);
                content.appendChild(category);
            } else if (categoryName === 'phoneFormat' || categoryName === 'disclosure') {
                const category = this.createInfoCategory(categoryName, items);
                content.appendChild(category);
            }
        });
        
        header.addEventListener('click', () => {
            header.classList.toggle('active');
            content.classList.toggle('active');
        });
        
        section.appendChild(header);
        section.appendChild(content);
        
        return section;
    }
    
    createCategory(categoryName, items) {
        const category = document.createElement('div');
        category.className = 'glossary-category';
        category.setAttribute('data-category', categoryName);
        
        const title = document.createElement('h4');
        title.textContent = categoryName.charAt(0).toUpperCase() + categoryName.slice(1);
        
        const itemsContainer = document.createElement('div');
        itemsContainer.className = 'glossary-items';
        
        items.forEach(item => {
            const itemElement = document.createElement('div');
            itemElement.className = 'glossary-item';
            
            // FIXED: Properly set searchable data for all item types
            let searchableText = '';
            let displayHTML = '';
            
            if (item.name && item.correct) {
                searchableText = `${item.name} ${item.correct}`.toLowerCase();
                displayHTML = `
                    <span class="name">${item.name}</span> → 
                    <span class="correct">${item.correct}</span>
                `;
            } else if (typeof item === 'string') {
                searchableText = item.toLowerCase();
                displayHTML = `<span class="correct">${item}</span>`;
            }
            
            // CRITICAL FIX: Set data-searchable attribute correctly
            itemElement.setAttribute('data-searchable', searchableText);
            itemElement.innerHTML = displayHTML;
            
            itemsContainer.appendChild(itemElement);
        });
        
        category.appendChild(title);
        category.appendChild(itemsContainer);
        
        return category;
    }
    
    createInfoCategory(categoryName, value) {
        const category = document.createElement('div');
        category.className = 'glossary-category';
        
        const title = document.createElement('h4');
        title.textContent = categoryName === 'phoneFormat' ? 'Phone Format' : 'Disclosure';
        
        const itemsContainer = document.createElement('div');
        itemsContainer.className = 'glossary-items';
        
        const itemElement = document.createElement('div');
        itemElement.className = 'glossary-item';
        // FIXED: Add searchable data for info items too
        itemElement.setAttribute('data-searchable', value.toLowerCase());
        itemElement.innerHTML = `<span class="correct">${value}</span>`;
        
        itemsContainer.appendChild(itemElement);
        category.appendChild(title);
        category.appendChild(itemsContainer);
        
        return category;
    }
    
    createCommonTermsSection() {
        const section = document.createElement('div');
        section.className = 'glossary-brand';
        section.setAttribute('data-brand', 'common');
        
        const header = document.createElement('div');
        header.className = 'glossary-brand-header';
        header.innerHTML = `
            <h3>Common Terms & Guidelines</h3>
            <span class="glossary-brand-toggle">▼</span>
        `;
        
        const content = document.createElement('div');
        content.className = 'glossary-brand-content';
        
        // Add common terms from commonTerms JSON
        Object.entries(commonTerms).forEach(([categoryName, items]) => {
            if (categoryName !== 'disclosures') {
                const category = this.createCommonCategory(categoryName, items);
                content.appendChild(category);
            }
        });
        
        header.addEventListener('click', () => {
            header.classList.toggle('active');
            content.classList.toggle('active');
        });
        
        section.appendChild(header);
        section.appendChild(content);
        
        return section;
    }
    
    createCommonCategory(categoryName, items) {
        const category = document.createElement('div');
        category.className = 'glossary-category';
        
        const title = document.createElement('h4');
        title.textContent = categoryName.charAt(0).toUpperCase() + categoryName.slice(1);
        
        const itemsContainer = document.createElement('div');
        itemsContainer.className = 'glossary-items';
        
        if (Array.isArray(items)) {
            items.forEach(item => {
                const itemElement = document.createElement('div');
                itemElement.className = 'glossary-item';
                // FIXED: Add searchable data for array items
                itemElement.setAttribute('data-searchable', item.toLowerCase());
                itemElement.innerHTML = `<span class="correct">${item}</span>`;
                itemsContainer.appendChild(itemElement);
            });
        } else if (typeof items === 'object') {
            Object.entries(items).forEach(([key, value]) => {
                const itemElement = document.createElement('div');
                itemElement.className = 'glossary-item';
                // FIXED: Properly set searchable data for object entries
                itemElement.setAttribute('data-searchable', `${key} ${value}`.toLowerCase());
                itemElement.innerHTML = `
                    <span class="name">${key}</span> → 
                    <span class="correct">${value}</span>
                `;
                itemsContainer.appendChild(itemElement);
            });
        }
        
        category.appendChild(title);
        category.appendChild(itemsContainer);
        
        return category;
    }
    
    // COMPLETELY REWRITTEN: Fixed search functionality
    filterGlossary(searchTerm) {
        const searchLower = searchTerm.toLowerCase().trim();
        
        // Get all elements
        const items = document.querySelectorAll('.glossary-item');
        const categories = document.querySelectorAll('.glossary-category');
        const brands = document.querySelectorAll('.glossary-brand');
        
        if (!searchLower) {
            // Show all items when search is empty
            items.forEach(item => item.style.display = 'block');
            categories.forEach(category => category.style.display = 'block');
            brands.forEach(brand => brand.style.display = 'block');
            return;
        }
        
        // Filter items
        items.forEach(item => {
            const searchableText = item.getAttribute('data-searchable') || '';
            const isVisible = searchableText.includes(searchLower);
            item.style.display = isVisible ? 'block' : 'none';
        });
        
        // Show/hide categories based on visible items
        categories.forEach(category => {
            const visibleItems = category.querySelectorAll('.glossary-item[style*="block"], .glossary-item:not([style*="none"])');
            const hasVisibleItems = Array.from(visibleItems).some(item => 
                item.style.display !== 'none'
            );
            category.style.display = hasVisibleItems ? 'block' : 'none';
        });
        
        // Show/hide brands based on visible categories
        brands.forEach(brand => {
            const visibleCategories = brand.querySelectorAll('.glossary-category[style*="block"], .glossary-category:not([style*="none"])');
            const hasVisibleCategories = Array.from(visibleCategories).some(category => 
                category.style.display !== 'none'
            );
            brand.style.display = hasVisibleCategories ? 'block' : 'none';
            
            // Auto-expand brands with search results
            if (hasVisibleCategories && searchLower) {
                const header = brand.querySelector('.glossary-brand-header');
                const content = brand.querySelector('.glossary-brand-content');
                header.classList.add('active');
                content.classList.add('active');
            }
        });
    }
}

// Initialize glossary when DOM is loaded
document.addEventListener('DOMContentLoaded', () => {
    new GlossaryManager();
});

    </script>
<!-- Glossary Toggle Button -->
<button class="glossary-toggle" id="glossaryToggle">📚 Glossary</button>

<!-- Glossary Modal -->
<div class="glossary-overlay" id="glossaryOverlay"></div>
<div class="glossary-modal" id="glossaryModal">
    <div class="glossary-header">
        <h2>📚 Brand Nomenclature Glossary</h2>
        <button class="glossary-close" id="glossaryClose">×</button>
    </div>
    <div class="glossary-content">
        <input type="text" class="glossary-search" id="glossarySearch" placeholder="🔍 Search terms, products, or features...">
        <div id="glossaryContainer"></div>
    </div>
</div>

</body>
</html>
